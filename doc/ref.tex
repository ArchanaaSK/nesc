% components included in an app

% when to mention fanout? (call, signal is possible first place)

% in-function static vars

% no initialisers on module variables (future support)
% vars w/ attribute C are not module vars

% post foo() has type bool

% ponder: should I define a minimum reachable fn defn ?
% (this def affects what ``missing connection'' errors you get)

% talk more about load order (affects behaviour because of includes)

\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{xspace}

\newcommand{\kw}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\nesc}{nesC\xspace}
\newcommand{\opt}{$_\mbox{opt}$\xspace}
\newcommand{\FSE}{\mathcal{F}}
\newcommand{\connect}{\mathcal{C}}

\parskip 0.15cm
\parindent 0cm

\begin{document}

\title{\nesc Language Reference Manual}
\author{David Gay, Philip Levis}
\date{September 2002}

\maketitle

\section{Introduction}

\nesc is a new programming language designed to embody the structuring
concepts and execution model of TinyOS~\cite{tinyos}. TinyOS is an
event-driven operating system designed for sensor network nodes that
have very limited resources (e.g. 8K program memory, 512 bytes of
RAM). TinyOS has been reimplemented in \nesc.

The basic concepts behind \nesc are:
\begin{itemize}
\item Separation of construction and composition: programs are built out of
\emph{components}, which are assembled (``wired'') to form whole
programs. Components define two scopes, one for their specification
(containing the names of their \emph{interface instances}) and one for
their implementation. Components have internal concurrency in the form of
\emph{tasks}. Threads of control may pass into a component through its
\emph{interfaces}. These threads are rooted either in a task or a hardware
interrupt.

\item Specification of component behaviour in terms of set of
\emph{interfaces}. Interfaces may be provided or used by the component. The
provided interfaces are intended to represent the functionality that the
component provides to its user, the used interfaces represent the
functionality the component needs to perform its job.

\item Interfaces are bidirectional: they specify a set of functions to be
implemented by the interface's provider (``commands'') and a set to be
implemented by the interface's user (``events''). This allows a single
interface to represent a complex interaction between components (e.g.,
registration of interest in some event, followed by a callback when
that event happens). This is critical because all lengthy commands in
TinyOS (e.g. send packet) are non-blocking; their completion is
signaled through an event (send done). By specifying interfaces, a
component cannot call the {\tt send} command unless it provides an
implementation of the {\tt sendDone} event.

Typically commands call downwards, i.e., from application components to
those closer to the hardware, while events call upwards. Certain primitive
events are bound to hardware interrupts (the nature of this binding is
system-dependent, so is not described further in this reference manual).

\item Components are statically linked to each other via their interfaces.
This increases runtime efficiency, encourages rubust design, and allows for
better static analysis of program's.

\item \nesc is designed under the expectation that code will be generated
by whole-program compilers. This should also allow for better code 
generation and analysis.
\end{itemize}

This document is a reference manual for \nesc rather than a tutorial. The
TinyOS tutorial~\cite{tinyos-tutorial} presents a gentler introduction
to \nesc.

The rest of this document is structured as follows:
Sections~\ref{sec:notation} and~\ref{sec:terminology} present the notation
and terminology used in the reference manual.
Sections~\ref{sec:interface},~\ref{sec:component},~\ref{sec:module},
and~\ref{sec:configuration} present \nesc interfaces and
components. Section~\ref{sec:app} explains how C files, \nesc interfaces
and components are assembled into an application. Section~\ref{sec:misc}
covers the remaining miscellaneous features of \nesc. Finally,
Section~\ref{sec:grammar} fully defines \nesc's grammar (as an extension to
the C grammar from Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr}).

\section{Notation}
\label{sec:notation}

The \texttt{typewriter} font is used for \nesc code and for filenames.

The grammar of \nesc is an extension the ANSI C grammar. We chose to base
our presentation on the ANSI C grammar from Appendix~A of Kernighan and
Ritchie (K\&R) ~\cite[pp234--239]{kandr}. We will not repeat productions
from that grammar here. Words in \emph{italics} are non-terminals and
non-literal terminals, \kw{typewriter} words and symbols are literal
terminals. The subscript \emph{opt} indicates optional terminals or
non-terminals. In some cases, we change some ANSI C grammar rules. We
indicate this as follows: \emph{also} indicates additional productions for
existing non-terminals, \emph{replaced by} indicates replacement of an
existing non-terminal. In the piecemeal presentation of the grammar, we
sometimes use \ldots to represent elided productions (not relevant to the
construction being presented).

The examples will often use the \code{uint8\_t}, \code{uint16\_t} types
from the standard \file{inttypes.h} file.

\section{Concepts and Terminology}
\label{sec:terminology}

We use the following terminology in the rest of the reference manual:

\begin{itemize}

\item \emph{component}: The basic unit of \nesc programs. Components have a
name and are of two kinds: \emph{modules} and \emph{configurations}. A
component has a \emph{specification} and an implementation. 

\item \emph{specification}: A list of \emph{specification elements}.

\item \emph{specification element}: An \emph{interface instance},
\emph{command} or \emph{event} in a specification that is either 
\emph{provided} or \emph{used}.

\item \emph{module}: A component whose implementation is provided by C code. 

\item \emph{configuration}: A component whose implementation is provided
by a composition of other components with a specific wiring.

\item \emph{interface type}: An \emph{interface type} specifies the
interaction between two components, \emph{the provider} and the
\emph{user}. This specification takes the form of a set of \emph{commands}
and \emph{events}. Each interface type has a distinct name. 

Interfaces are bi-directional: the provider of an interface implements its
commands, the user of an interface implements its events.

\item \emph{command}, \emph{event}: A function that is part of a component's
specification, either directly as a specification element or within one 
of the component's interface instances.

When used directly as specification elements, commands and events can have
\emph{interface parameters}. As with interface instances, we distinguish
between \emph{simple commands (events)} without interface parameters and
\emph{parameterised commands (events)} with interface parameters. The
interface parameters of a command or event are distinct from its regular
function parameters.

%\item \emph{interface function}: A command or event. When the context is
%unambiguous, we will just say function.

\item \emph{interface instance}: An instance of a particular interface type
in the specification of a component. An interface instance has an instance
name, a \emph{role} (provider or user), an interface type and, optionally,
\emph{interface parameters}. An interface instance without parameters is a
\emph{simple interface instance}, with parameters it is a
\emph{parameterised interface instance}.

\item \emph{interface parameter}: An interface parameter has an interface
parameter name and must be of integral type. 

There is (conceptually) a separate simple interface instance for each
distinct list of parameter values of a parameterised interface instance
(and, similarly, separate simple commands or events in the case of
parameterised commands or events). Parameterised interface instances allow
runtime selection based on parameter values between a set of commands (or
between a set of events).

\item \emph{interface}: When the context is unambiguous, we will say
interface to refer to either an interface type or an interface instance.

\item \emph{task}: A TinyOS task.

\item \emph{scopes}: \nesc has the standard C global, function-parameter
and block scopes. Additionally there are per-component-specification,
per-component-implementation and per-interface-type scopes.

\item \emph{namespaces}: \nesc has the standard C variable (also used for
functions and \emph{typedefs}), tagged type (\code{struct}, \code{union}
and \code{enum} tag names) and label namespaces. Additionally, \nesc has a
component and interface type namespace for component and interface type
names.

\item \emph{extents}: \nesc has the standard C extents: indefinite,
per-function, and per-block.

\item \emph{compile-time error}: An error that the \nesc compiler must
report at compile-time.

\end{itemize}

\section{Interfaces}
\label{sec:interface}

Interfaces in \nesc are bidirectional: they specify a multi-function
interaction channel between two components. An interface has two ``sides'':
the provider and the user. The interface specifies a set of functions,
called commands, to be implemented by the interface's provider and a set of
functions, called events, to be implemented by the interface's
user. 

This section explains how interfaces are specified,
Section~\ref{sec:component} explains how components specify the interfaces
they provide and use, Section~\ref{sec:module} explains how commands and
events are called from C code and Section~\ref{sec:configuration} explains
how components are linked together via their interfaces.

Interfaces are specified by interface types, as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	\ldots\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
This declares interface type \emph{identifier}. This identifier has global
scope and belongs to the component and interface type namespace (so all
interface types have names distinct from each other and from all
components). 

Each interface type has a separate scope for the declarations in
\emph{declaration-list}. This \emph{declaration-list} must consist of
function declarations with the \kw{command} or \kw{event} storage class (if
not, a compile-time error occurs).

An interface can optionally include C files via the \emph{includes-list}
(see Section~\ref{sec:app}).

A simple interface is:
\begin{verbatim}
interface SendMsg { 
  command result_t send(uint16_t address, uint8_t length, TOS_MsgPtr msg);
  event result_t sendDone(TOS_MsgPtr msg, result_t success);
}
\end{verbatim}

Provides of the \code{SendMsg} interface type must implement the
\code{send} command, while users must implement the \code{sendDone} event.

\section{Component Specification}
\label{sec:component}

A \nesc component is either a module or a configuration:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\>	\ldots\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\end{tabbing}}
Component's names are specified by the \emph{identifier}. This identifier
has global scope and belongs to the component and interface type namespace.
A component introduces two per-component scopes: a specification scope,
nested in the C global scope, and an implementation scope nested in the
specification scope.

A component can optionally include C files via the \emph{includes-list}
(see Section~\ref{sec:app}).

The \emph{specification} lists the specification elements (interface
instances, commands or events) used or provided by this
component. Typically, commands call down towards the hardware components
and events call up towards application components. A thread of control
crosses components only though its specification elements.

Each specification element has a name (interface instance name, command
name or event name). These names belong to the variable namespace of the
per-component-specification scope.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\end{tabbing}}
There can be multiple \kw{uses} and \kw{provides} directives. Multiple used
or provided specification elements can be grouped in a single directive by
surrounding them with \{ and \}. For instance, the following two
specifications are identical:

\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses interface X;
  uses interface Y;
} ...
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses {
    interface X;
    interface Y;
  }
} ...
\end{verbatim}
\end{minipage}

An interface instance is specified as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\>	\ldots\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
interface-parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

The complete syntax for interface instance declaration is \code{interface X
as Y}, explicitly specifying \code{Y} as the instance's name. The
\code{interface X} syntax is a shorthand for \code{interface X as X}.

If the \emph{interface-parameters} are omitted, then \code{interface X as
Y} declares a simple interface instance, corresponding to a single
interface to this component. If the \emph{interface-parameters} are present
(e.g., \code{interface SendMsg S[uint8\_t id]}) then this is a declaration
of a parameterised interface instance, corresponding to multiple interfaces
to this component, one for each distinct tuple of parameter values (so
\code{interface SendMsg S[uint8\_t id]} declares 256 interfaces of type
\code{SendMsg}). The types of the \emph{parameters} must be integral types
(\kw{enum}s are not allowed at this time).

Commands or events can be included directly as specification elements by
including a standard C function declaration with
\kw{command} or \kw{event} as its storage class specifier:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	declaration\\
\>	\ldots\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
It is a compile-time error if the \emph{declaration} is not a function
declaration with the \kw{command} or \kw{event} storage class. 

As with interface instances, commands and events are simple commands or
events if no interface parameters are specified, or parameterised commands
or events if interface parameters are specified. The
\emph{interface-parameters} are placed before the function's regular
parameter list, e.g., \code{command void send[uint8\_t id](int x)}:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
direct-declarator: \emph{also}\\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\>	\ldots
\end{tabbing}}
Note that interface parameters are only allowed on commands or events within
component specifications, not within interface types.

Here is a full specification example:
\begin{verbatim}
configuration GenericComm {
  provides {
    interface StdControl as Control;
    interface SendVarLenPacket;
    
    // The interface are parameterised by the active message id
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
  }
  uses {
    // signaled after every send completion for components which wish to
    // retry failed sends
    event result_t sendDone();
  }
} ...
\end{verbatim}
In this example, \code{GenericComm}:
\begin{itemize}
\item Provides simple interface instance \code{Control} of type
\code{StdControl}.
\item Provides simple interface instance \code{SendVarLenPacket} of type
\code{SendVarLenPacket}.
\item Provides parameterised instances of interface type \code{SendMsg} and
\code{ReceiveMsg}; the parameterised instances are named \code{SendMsg} and
\code{ReceiveMsg} respectively.
\item Uses event \code{sendDone}.
\end{itemize}

We say that a command (event) $F$ provided in the specification of
component $K$ is \emph{provided command (event)} $F$ of $K$; similarly, a
command (event) used in the specification of component $K$ is \emph{used
command (event)} $F$ of $K$.

A command $F$ in a provided interface instance $X$ of component $K$ is
provided command $X.F$ of $K$; a command $F$ in a used interface instance
$X$ of $K$ is used command $X.F$ of $K$; an event $F$ in a provided
interface instance $X$ of $K$ is used event $X.F$ of $K$; and an event $F$
in a used interface instance $X$ of $K$ is provided event $X.F$ of $K$
(note the reversal of used and provided for events due to the bidirectional
nature of interfaces). 

We will often simply refer to the ``command or event $\alpha$ of $K$'' when
the used/provided distinction is not relevant.  Commands or events $\alpha$
of $K$ may be parameterised or simple, depending on the parameterised or
simple status of the specification element to which they correspond.

\section{Modules}
\label{sec:module}

Modules implement a component specification with C code:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\end{tabbing}}
where \emph{translation-unit} is a list of C declarations and definitions
(see K\&R~\cite[pp234--239]{kandr}). 

The top-level declarations of the module's \emph{translation-unit} belong
to the module's per-component-implementation scope. These declarations have
indefinite extent and can be: any standard C declaration or definition, a
TinyOS task declaration or definition, a commands or event
implementation.

\subsection{Implementing the Module's Specification}

The \emph{translation-unit} must implement the all provided commands
(events) $\alpha$ of the module (i.e., all directly provided commands and
events, all commands in provided interfaces and all events in used
interfaces). A module can call any of its commands and signal any of its
events.

These command and event implementations are specified with the following C
syntax extensions:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator interface-parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
The implementation of simple command or event $\alpha$ has the syntax of a C
function definition for $\alpha$ (note the extension to
\emph{direct-declarator} to allow \code{.} in function names) with storage
class \kw{command} or \kw{event}. For example, in a module that provides
interface \code{Send} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send(uint16_t address, uint8_t length, TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

The implementation of parameterised command or event $\alpha$ with interface
parameters $P$ has the syntax of a C function definition for $\alpha$ with
storage class \kw{command} or \kw{event} where the function's regular
parameter list is prefixed with the parameters $P$ within square brackets
(this is the same syntax as parameterised command or event declarations
within a component specification). These interface parameter declarations
$P$ belong to $\alpha$'s function-parameter scope and have the same extent
as regular function parameters. For example, in a module that provides
interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send[uint8_t id](uint16_t address, uint8_t length, 
                                       TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

Compile-time errors are reported when:
\begin{itemize}
\item There is no implementation for a provided command or event.
\item The type signature (and optional interface parameters) of a command or
event does not match that given in the module's specification.
\end{itemize}

\subsection{Calling Commands and Signaling Events}

The following extensions to C syntax are used to call events and signal
commands:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
postfix-expression:\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	\ldots
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}

A simple command $\alpha$ is called with \code{call $\alpha$(...)}, a
simple event $\alpha$ is signaled with \code{signal $\alpha$(...)}. For
instance, in a module that uses interface \code{Send} of type \kw{SendMsg}:
\code{call Send.send(1, sizeof(Message), &msg1)}.

A parameterised command $\alpha$ (respectively, an event) with $n$
parameters of type $\tau_1, \ldots, \tau_n$ is called with interface parameters
expressions $e_1, \ldots, e_n$ as follows: \code{call $\alpha$[$e_1, \ldots,
e_n$](...)}  (respectively, \code{signal $\alpha$[$e_1, \ldots,
e_n$](...)}). Interface parameter expression $e_i$ must be assignable to type
$\tau_i$; the actual interface parameter value is $e_i$ cast to type
$\tau_i$. For instance, in a module that uses interface \code{Send[uint8\_t
id]} of type \kw{SendMsg}:

\begin{verbatim}
  int x = ...;
  call Send.send[x + 1](1, sizeof(Message), &msg1);
\end{verbatim}

Execution of commands and events is immediate, i.e., \kw{call} and
\kw{signal} behave similarly to function calls. The actual command or event
implementations executed by a \code{call} or \code{signal} expression
depend on the wiring statements in the program's configurations. These
wiring statements may specify that 0, 1 or more implementations are to be
executed. When more than 1 implementation is executed, we say that the
module's command or event has ``fan-out''.  

A module can specify a default implementation for a used command or event
$\alpha$ that it calls or signals. A compile-time error occurs for default
implementations of provided commands or events. Default implementations are
executed when $\alpha$ is not connected to any command or event
implementation. A default command or event is defined by prefixing a
command or event implementation with the \kw{default} keyword:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\end{tabbing}}
For instance, in a in a module that uses interface \code{Send} of type
\kw{SendMsg}:
\begin{verbatim}
default command result_t Send.send(uint16_t address, uint8_t length, 
                                   TOS_MsgPtr msg) {
  return SUCCESS;
}
/* call is allowed even if interface Send is not connected */
... call Send.send(1, sizeof(Message), &msg1) ...
\end{verbatim}

Section~\ref{sec:wiring-semantics} specifies what command or event
implementations are actually executed and what result gets returned in all
cases.

\subsection{Tasks}

A TinyOS task is an independent locus of control defined by a function of
storage class \kw{task} returning \kw{void} and with no arguments:
\code{task void myTask() \{ ... \}}.\footnote{\nesc functions with no
arguments are declared with \code{()}, not \code{(void)}. See
Section~\ref{sec:misc-void}.} A task can also have a forward declaration, e.g.,
\code{task void myTask();}.

Tasks are posted by prefixing a call to the task with \kw{post}, e.g.,
\code{post myTask()}. Post returns immediately; its return value is 1 if
the task was successfully posted for independent execution, 0
otherwise. The type of a post expression is \code{unsigned char}.

  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{task}\\
\\
call-kind: \emph{also one of}\\
\>	\kw{post}
\end{tabbing}}

\section{Configurations}
\label{sec:configuration}

Configurations implement a component specification by connecting, or wiring,
together a collection of other components:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\end{tabbing}}

The \emph{component-list} lists the components that are used to build this
configuration, the \emph{connection-list} specifies how these components
are wired to each other and to the configuration's specification.

In the rest of this section, we call specification elements from the
configuration's specification \emph{external},
and specification elements from one of the configuration's components
\emph{internal}.

\subsection{Included components}
\label{sec:config-components}

The \emph{component-list} specifies the components used to build this
configuration. These components can be optionally renamed within the
configuration, either to avoid name conflicts with the configuration's
specification elements, or to simplify changing the components a
configuration uses (to avoid having to change the wiring). The names
chosen for components belong to the component's implementation scope.

\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\end{tabbing}}

A compile-time error occurs if two components are given the same name using \kw{as} (e.g., \code{components X, Y as X}).

There is only ever a single instance of a component: if a component $K$
is used in two different configurations (or even twice within the same
configuration) there is still only instance of $K$ (and its variables)
in the program.

\subsection{Wiring}
\label{sec:wiring}

Wiring is used to connect specification elements (interfaces, commands,
events) together. This section and the next (Section~\ref{sec:implicit})
define the syntax and compile-time rules for
wiring. Section~\ref{sec:wiring-semantics} details how a program's wiring
statements dictate which functions get called at each \kw{call} and
\kw{signal} expression.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\end{tabbing}}


Wiring statements connect two \emph{endpoints}. The \emph{identifier-path}
of an \emph{endpoint} specifies a specification element. The
\emph{argument-expression-list} optionally specifies interface parameter
values. We say that an endpoint is parameterised if its specification
element is parameterised and the endpoint has no parameter values. A
compile-time error occurs if an endpoint has parameter values and any of
the following is true:
\begin{itemize}
\item The parameter values are not all constant expressions.
\item The endpoint's specification element is not parameterised.
\item The parameter values are not in range for the specification element's
parameter types.
\end{itemize}

A compile-time error occurs if the \emph{identifier-path} of an
\emph{endpoint} is not of one the three following forms:
\begin{itemize}
\item $X$, where $X$ names an external specification element.
\item $K.X$ where $K$ is a component from the \emph{component-list} and
$X$ is a specification element of $K$.
\item $K$ where $K$ is a some component name from the \emph{component-list}.
This form is used in implicit connections, discussed in
Section~\ref{sec:implicit}. Note that this form cannot be used when
parameter values are specified.
\end{itemize}

There are three wiring statements in \nesc:
\begin{itemize}
\item \emph{endpoint}$_1$ \code{=} \emph{endpoint}$_2$ \ (equate wires):
Any connection involving an external specification element. These
effectively make two specification elements equivalent.

Let $S_1$ be the specification element of \emph{endpoint}$_1$ and $S_2$
that of \emph{endpoint}$_2$. One of the following two conditions must hold
or a compile-time error occurs:
\begin{itemize}
\item $S_1$ is internal, $S_2$ is external (or vice-versa) and $S_1$ and
$S_2$ are both provided or both used,
\item $S_1$ and $S_2$ are both external and one is provided and the other used.
\end{itemize}

\item \emph{endpoint}$_1$ \code{->} \emph{endpoint}$_2$ \ (link wires): A
connection involving two internal specification elements. Link wires always
connect a used specification element specified by \emph{endpoint}$_1$ to a
provided one specified by \emph{endpoint}$_2$ . If these two conditions do
not hold, a compile-time error occurs.

\item \emph{endpoint}$_1$ \code{<-} \emph{endpoint}$_2$ is equivalent to
\emph{endpoint}$_2$ \code{->} \emph{endpoint}$_1$.
\end{itemize}

In all three kinds of wiring, the two specification elements specified must
be compatible, i.e., they must both be commands, or both be events, or both
be interface instances. Also, if they are commands (or events), then they
must both have the same function signature. If they are interface instances
they must be of the same interface type. If these conditions do not hold,
a compile-time error occurs.

If one endpoint is parameterised, the other must be too and must have the
same parameter types; otherwise a compile-time error occurs.

The same specification element may be connected multiple times, e.g.,:
\begin{verbatim}
configuration C {
  provides interface X;
} implementation {
  components C1, C2;

  X = C1.X;
  X = C2.X;
}
\end{verbatim}
In this example, the multiple wiring will lead to multiple signalers
(``fan-in'') for the events in interface \code{X} and for multiple
functions being executed (``fan-out'') when commands in interface \code{X}
are called. Note that multiple wiring can also happen when two
configurations independently wire the same interface, e.g.:
\begin{verbatim}
configuration C { }           configuration D { }
implementation {              implementation {
  components C1, C2;            components C3, C2;

  C1.Y -> C2.Y;                 C3.Y -> C2.Y;
}                             }
\end{verbatim}

All external specification elements must be wired or a compile-time error
occurs. However, internal specification elements may be left unconnected
(these may be wired in another configuration, or they may be left unwired
if the modules have the appropriate \kw{default} event or command
implementations).

\subsection{Implicit Connections}
\label{sec:implicit}

It is possible to write \code{$K_1$ <- $K_2$.$X$} or \code{$K_1$.$X$ <-
$K_2$}(and the same with \kw{=}, or \kw{->}). This syntax iterates through
the specification elements of $K_1$ (resp. $K_2$) to find a specification
element $Y$ such that \code{$K_1$.$Y$ <- $K_2$.$X$} (resp. \code{$K_1$.$X$
<- $K_2$.$Y$}) forms a valid connection. If exactly one such $Y$ can
be found, then the connection is made, otherwise a compile-time error
occurs.

For instance, with:
\begin{verbatim}
module M1 {                              module M2 {
  provides interface StdControl;           uses interface StdControl as SC;
} ...                                    } ...

              configuration C { }
              implementation {
                components M1, M2;
                M2.SC -> M1;
              }
\end{verbatim}
The \code{M2.SC -> M1} line is equivalent to \code{M2.SC -> M1.StdControl}.

\subsection{Wiring Semantics}
\label{sec:wiring-semantics}

We first explain the semantics of wiring in the absence of parameterised
interfaces. Section~\ref{sec:wiring-parms} below covers parameterised
interfaces. Finally, Section~\ref{sec:wiring-reqs} specifies requirements
on the wiring statements of an application when viewed as a whole.

We define the meaning of wiring in terms of \emph{intermediate
functions}.\footnote{\nesc can be compiled without explicit intermediate
functions, so the behaviour described in this section has no runtime cost
beyond the actual function calls and the runtime dispatch necessary for
parameterised commands or events.}  There is one intermediate function
$I_\alpha$ for every command or event $\alpha$ of every component. For
instance, with
\begin{verbatim}
interface X {             module M {
  command void f();         provides interface X as P;
  event void g();           uses interface X as U;
}                           provides command void h();
                          } implementation { ... }
\end{verbatim}
module M has intermediate functions \code{M.P.f, M.P.g, M.U.f, M.U.g, M.h}.
In examples in the rest of this section we name intermediate functions
based on their component, optional interface instance name and function
name.

An intermediate function is either used or provided. Each intermediate
function takes the same arguments as the corresponding command or event in
the component's specification. The body of an intermediate function $I$ is
a list of calls (executed sequentially) to other intermediate
functions. These other intermediate functions are the functions to which
$I$ is connected by the application's wiring statements. The arguments $I$
receives are passed on to the called intermediate functions unchanged. The
result of $I$ is a list of results (the type of list elements is the result
type of the command or event corresponding to $I$), built by concatenating
the result lists of the called intermediate functions. An intermediate
function which returns an empty result list corresponds to an unconnected
command or event; an intermediate function which returns a list of two or
more elements corresponds to ``fan-out''.

\paragraph{Intermediate Functions and Configurations}

The wiring statements in a configuration specify the body of intermediate
functions. We first expand the wiring statements to refer to intermediate
functions rather than specification elements, and we suppress the
distinction between \code{=} and \code{->} wiring statements. We write
\code{$I_1$ <-> $I_2$} for a connection between intermediate functions
\code{$I_1$} and \code{$I_2$}. For instance, in:
\begin{verbatim}
interface X {             module M {
  command void f();         provides interface X as P;
  event void g();           uses interface X as U;
}                           provides command void h();
                          } implementation { ... }
configuration C {
  provides interface X;
  provides command void h2();
}
implementation {
  components M;
  X = M.P;
  M.U -> M.P;
  h2 = M.h;
}  
\end{verbatim}
we have the following intermediate function connections:\\
\begin{tabular}{ccc}
\code{C.X.f <-> M.P.f} & \code{M.U.f <-> M.P.f} & \code{C.h2 <-> M.h} \\
\code{C.X.g <-> M.P.g} & \code{M.U.g <-> M.P.g}
\end{tabular}

In a connection \code{$I_1$ <-> $I_2$} from a configuration
$C$ one of the two intermediate functions is the \emph{callee} and the
other is the \emph{caller}. The connection simply specifies that a call to
the callee is added to the body of the caller. \code{$I_1$}
(similarly, \code{$I_2$}) is a callee if any of the following conditions hold
(we use the internal, external terminology for specification elements with
respect to the configuration $C$ containing the connection):
\begin{itemize}
\item If \code{$I_1$} corresponds to an internal specification element that
is a provided command or event.
\item If \code{$I_1$} corresponds to an external specification element that
is a used command or event.
\item If \code{$I_1$} corresponds to a command of interface instance $X$,
and $X$ is an internal, provided or external, used specification element.
\item If \code{$I_1$} corresponds to an event of interface instance $X$,
and $X$ is an external, provided or internal, used specification element.
\end{itemize}
If none of these conditions hold, \code{$I_1$} is a caller. The rules for
wiring in Section~\ref{sec:wiring} ensure that a connection \code{$I_1$ <->
$I_2$} cannot connect two callers or two callees. In our previous example,
in configuration \code{C}, \code{C.X.f, C.h2, M.P.g, M.U.f} are callers
and \code{C.X.g, M.P.f, M.U.g, M.h} are callees. Thus the connections of
\code{C} specify that a call to \code{M.P.f} is added to \code{C.X.f}, a
call to \code{C.X.g} is added to \code{M.P.g}, etc.


\paragraph{Intermediate Functions and Modules}

The C code in modules calls, and is called by, intermediate functions. 

The intermediate function $I$ for provided command or event $\alpha$ of
module $M$ contains a single call to the implementation of $\alpha$ in
$M$. Its result is the singleton list of this call's result.

The expression \code{call} $\alpha(e_1, \ldots, e_n)$ is evaluated as
follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.
\item The intermediate function $I$ corresponding to $\alpha$ is called
with arguments $v_1, \ldots, v_n$, with results list $L$.
\item If $L$ has one or more elements, the result of the \code{call} is an
arbitrary element chosen from $L$.
\item If $L$ is empty the default implementation for $\alpha$ is
called with arguments $v_1, \ldots, v_n$, and its result is the result of
the \code{call}. Section~\ref{sec:wiring-reqs} specifies that a
compile-time error occurs if $L$ can be empty and there is no default
implementation for $\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

\subsubsection{Wiring and Parameterised Functions}
\label{sec:wiring-parms}

If a command or event $\alpha$ of component $K$ is parameterised with
interface parameters of type $\tau_1, \ldots, \tau_n$ then there is an
intermediate function $I_{\alpha,v_1,\ldots,v_n}$ for every distinct tuple
$(v_1:\tau_1, \ldots, v_n:\tau_n)$.

In modules, if intermediate function $I_{v_1, \ldots, v_n}$ corresponds
to parameterised, provided command (or event) $\alpha$ then the call in
$I_{v_1, \ldots, v_n}$ to $\alpha$'s implementation passes values $v_1,
\ldots, v_n$ as the values for $\alpha$'s interface parameters. 

The expression \code{call} $\alpha[e'_1, \ldots, e'_m](e_1, \ldots, e_n)$
is evaluated as follows:
\begin{itemize}
\item The arguments $e_1, \ldots, e_n$ are evaluated, giving values $v_1,
\ldots, v_n$.
\item The arguments $e'_1, \ldots, e'_m$ are evaluated, giving values $v'_1,
\ldots, v'_m$.
\item The $v'_i$ values are cast to type $\tau_i$, where $\tau_i$ is the
type of the $i$th interface parameter of $\alpha$.
\item The intermediate function $I_{v'_1,\ldots,v'_m}$ corresponding to
$\alpha$ is called with arguments $v_1, \ldots, v_n$, with results list
$L$.\footnote{This call typically involves a runtime selection between
several command implementations - this is the only place where intermediate
functions have a runtime cost.}
\item If $L$ has one or more elements, the result of the \code{call} is an
arbitrary element chosen from $L$.
\item If $L$ is empty the default implementation for $\alpha$ is called
with interface parameter values $v'_1, \ldots, v'_m$ and arguments $v_1,
\ldots, v_n$, and its result is the result of the
\code{call}. Section~\ref{sec:wiring-reqs} specifies that a compile-time
error occurs if $L$ can be empty and there is no default implementation for
$\alpha$.
\end{itemize}
The rules for \code{signal} expressions are identical.

There are two cases when an endpoint in a wiring statement refers to a
parameterised specification element:
\begin{itemize}
\item The endpoint specifies parameter values $v_1, \ldots, v_n$. If the
endpoint corresponds to commands or events $\alpha_1, \ldots, \alpha_m$
then the corresponding intermediate functions are
$I_{\alpha_1,v_1,\ldots,v_n}$, \ldots, $I_{\alpha_m,v_1,\ldots,v_n}$ and
wiring behaves as before.
\item The endpoint does not specify parameter values. In this case, both
endpoints in the wiring statement correspond to parameterised specification
elements, with identical interface parameter types $\tau_1, \ldots,
\tau_n$. If one endpoint corresponds to commands or events $\alpha_1,
\ldots, \alpha_m$ and the other to corresponds to commands or events
$\beta_1, \ldots, \beta_m$, then there is a connection $I_{\alpha_i, w_1,
\ldots, w_n} \code{<->} I_{\beta_i, w_1,\ldots, w_n}$ for all $1 \leq i
\leq m$ and all tuples $(w_1:\tau_1, \ldots, w_n:\tau_n)$ (i.e., the
endpoints are connected for all corresponding parameter values).
\end{itemize}

\subsubsection{Application-level Requirements}
\label{sec:wiring-reqs}

There are two requirement that the wiring statements of an application must
satisfy, or a compile-time error occurs:
\begin{itemize}
\item There must be no infinite loop involving only intermediate functions.
\item At every \code{call $\alpha$} (or \code{signal $\alpha$}) expression
in the application's modules:
\begin{itemize}
\item If the call is unparameterised: if the call returns no results there
must be a default implementation of $\alpha$.
\item If the call is parameterised: if substituation of any values for the
interface parameters of $\alpha$ returns no results there must be a default
implementation of $\alpha$ (note that this condition does not consider the
expressions used to specify interface parameter values at the call-site).
\end{itemize}
\end{itemize}

\section{\nesc Applications}
\label{sec:app}

A \nesc application has three parts: a list of C declarations and
definitions, a set of interface types and a set of components. The naming
environment of \nesc applications is structured as follows:
\begin{itemize}
\item An outermost, global scope with three namespaces: a C variable and a
C tag namespace for the C declarations and definitions, and a component and
interface type namespace for the \nesc interface types and components.
\item C declarations and definitions may introduce their own nested scopes
within the global scope, as usual (for function declarations and
definitions, code blocks within functions, etc).

\item Each interface type introduces has a scope that holds the interface's
commands or events. This scope is nested in the global scope, therefore
command and event definitions can refer to C types and tags defined in the
global scope.

\item Each component introduces two new scopes. The specification scope,
nested in the global scope, contains a variable namespace which holds the
component's specification elements. The implementation scope, nested in the
specification scope, contains a variable and a tag namespace. 

For configurations, the implementation's scope variable namespace contains
the names by which this component refers to its included components
(Section~\ref{sec:config-components}). For modules, the implementation
scope holds the command and event implementations, tasks, C declarations
and definitions that form the module's body. These declarations, etc may
introduce their own nested scopes within the implementation scope (for
function bodies, code blocks, etc). As a result of the scope nesting
structure, code in modules has access to the C declarations and definitions
in the global scope, but not to any declarations or definitions in other
components.
\end{itemize}

The C declarations and defintions, interface types and components that form
a \nesc application are determined by an on-demand loading process. The
input to the \nesc compiler is a single component $K$. The \nesc compiler
first loads C file \file{tos} (Section~\ref{sec:load-c}), then loads
component $K$ (Section~\ref{sec:load-component}). The code for the
application is all the code loaded as part of the process of loading these
two files. A \nesc compiler can assume that all calls to functions,
commands or events not marked with the \code{spontaneous} attribute
(Section~\ref{sec:attributes}) occur in the loaded code (i.e., there are no
``invisible'' calls to non-\code{spontaneous} functions).\footnote{For
instance, the current \nesc compiler uses this information to eliminate
unreachable code.}

Part of the process of loading a C file, \nesc component or interface type
involves locating the corresponding source file. The mechanism used to
locate files is outside the scope of this reference manual; for details on
how this works in the current compiler please see the \file{ncc} man page.

\subsection{Loading C file $X$}
\label{sec:load-c}

If $X$ has already been loaded, nothing more is done. Otherwise, file $X$.h
is located and preprocessed. Changes made to C macros (via \code{\#define}
and \code{\#undef}) are visible to all subsequently preprocessed files. The C
declarations and definitions from the preprocessed $X$.h file are entered
into the C global scope, and are therefore visible to all subsequently
processed C files, interface types and components.

\subsection{Loading Component $K$}
\label{sec:load-component}

If $K$ has already been loaded, nothing more is done. Otherwise, file
$X$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed using the following grammar: \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\end{tabbing}}
If $X$.nc does not define \code{module $K$} or \code{configuration $K$}, a
compile-time error is reported. Otherwise, all C files specified by the
\emph{includes-list} are loaded (Section~\ref{sec:load-c}). Then all
interface types used in the component's specification are loaded
(Section~\ref{sec:load-intf}). Next, the component specification is
processed (Section~\ref{sec:component}). If $K$ is a configuration, all
components specified (Section~\ref{sec:config-components}) by $K$ are
loaded (Section~\ref{sec:load-component}). Finally, $K$'s implementation is
processed (Sections~\ref{sec:module} and~\ref{sec:configuration})..

\subsection{Loading Interface Type $I$}
\label{sec:load-intf}

If $I$ has already been loaded, nothing more is done. Otherwise, file
$X$.nc is located and preprocessed. Changes made to C macros (via
\code{\#define} and \code{\#undef}) are discarded. The preprocessed file is
parsed following the \emph{nesC-file} production above. If $X$.nc does not
define \code{interface $I$} a compile-time error is reported. Otherwise,
all C files specified by the \emph{includes-list} are loaded
(Section~\ref{sec:load-c}). Then $I$'s definition is processed
(Section~\ref{sec:interface}).

As an example of including C files in components or interfaces, interface
type \code{Bar} might include C file \file{BarTypes.h} which defines types
used in \code{Bar}:

\begin{minipage}[t]{3in}
\begin{verbatim}
Bar.nc:
includes BarTypes;
interface Bar {
  command result_t bar(BarType arg1);
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
BarTypes.h:
typedef struct {
  int x;
  double y;
} BarType;
\end{verbatim}
\end{minipage}

The definition of interface \code{Bar} can refer to \code{BarType}, as can
any component that uses or provides interface \code{Bar} (interface
\code{Bar}, and hence \file{BarTypes.h}, are loaded before any such
component's specification or implementation are processed).

\section{Miscellaneous}
\label{sec:misc}

\subsection{Functions with no arguments, old-style C declarations}
\label{sec:misc-void}

\nesc functions with no arguments are declared with \code{()}, not
\code{(void)}. The latter syntax reports a compile-time error.

Old-style C declarations (with \code{()}) and function definitions 
(parameters specified after the argument list) are not allowed in
interfaces or components (and cause compile-time errors).

Note that neither of these changes apply to C files (so that existing
\file{.h} files can be used unchanged).

\subsection{// comments}

\nesc allows // comments in C, interface type and component files.

\subsection{Attributes}
\label{sec:attributes}

\nesc uses gcc's~\cite{gcc} \kw{\_\_attribute\_\_} syntax for
declaring some properties of functions. These attributes can be placed
either on function definitions or function declarations (after the
parameter list).\footnote{gcc doesn't allow attributes after the
parameter list in function definitions.} The attributes of a function
$f$ are the union of all attributes on all declarations and
definitions of $f$.

The attribute syntax in \nesc is:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\end{tabbing}}

\nesc supports two attributes:
\begin{itemize}
\item \code{C}: This attribute is used for a function $f$ declared in
modules (it is ignored for all other declarations). It specifies that
$f$'s should appear in the global C scope rather than in the module's
per-component-implementation scope. This allows $f$ to be called from
C code.

\item \code{spontaneous}: This attribute can be used on any function
$f$ (in modules or C code). It indicates that there are calls $f$ that
are not visible in the source code. Typically, functions that are
called spontaneously are interrupt handlers, and the C \code{main}
function. Section~\ref{sec:app} discusses how the \nesc compiler
uses the \code{spontaneous} attribute during compilation.
\end{itemize}

Example of attribute use: in module \file{RealMain.td}:
\begin{verbatim}
module RealMain { ... }
implementation {
  int main(int argc, char **argv) __attribute__((C, spontaneous)) {
    ...
  }
}
\end{verbatim}

This example declares that function \code{main} should actually appear
in the C global scope (\code{C}), so that the linker can find it. It
also declares that \code{main} can be called even though there are no
function calls to \code{main} anywhere in the program
(\code{spontaneous}). 

\subsection{Compile-time Constant Functions}

\nesc has a new kind of constant expression: \emph{constant
functions}. These are functions defined within the language which
evaluate to a constant at compile-time.

\nesc currently has one constant function, \code{unique}. More are planned
for the near future.

\code{unsigned int unique(char *identifier)} \\ Returns: if the program
contains $n$ calls to \code{unique} with the same \code{identifier}
string, each calls returns a different unsigned integer in the range
$0 .. n-1$.

The intended use of \code{unique} is for passing a unique integer
to parameterised interface instances, so that a component providing
a parameterised interface can uniquely identify the various components
connected to that interface.

\section{Grammar}
\label{sec:grammar}

Please refer to  Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr} while reading this grammar.

The following keywords are new for \nesc: \kw{as}, \kw{call}, \kw{command},
\kw{components}, \kw{configuration}, \kw{event}, \kw{implementation},
\kw{interface}, \kw{module}, \kw{post}, \kw{provides}, \kw{signal},
\kw{task}, \kw{uses}, \kw{includes}. These \nesc keywords are not reserved
in C files. The corresponding C symbols are accessible in \nesc files by
prefixing them with \kw{\_\_nesc\_}\emph{keyword} (e.g.,
\kw{\_\_nesc\_keyword\_as}).

\nesc reserves all identifiers starting with \kw{\_\_nesc} for internal
use. TinyOS reserves all identifiers starting with \kw{TOS\_} and
\kw{TOSH\_}.

\nesc files follow the \emph{nesC-file} production; \file{.h} files included
via the \kw{includes} directive follow the \emph{translation-unit}
directive from K\&R. 

New rules:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\\
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\\
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\\
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\\
specification-element:\\
\>	declaration\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

Changed rules: 
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{task}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\\
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\\
postfix-expression: \emph{replaced by}\\
\>	primary-expression\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	postfix-expression \kw{.} identifier\\
\>	postfix-expression \kw{->} identifier\\
\>	postfix-expression \kw{++}\\
\>	postfix-expression \kw{--}\\
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}


\end{document}
