% ponder: should I define a minimum reachable fn defn ?
% (this def affects what ``missing connection'' errors you get)

\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{xspace}

\newcommand{\kw}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\nesc}{nesC\xspace}
\newcommand{\opt}{$_\mbox{opt}$\xspace}

\parskip 0.15cm
\parindent 0cm

\begin{document}

\section{Introduction}

1 para goal (execution model embodies TinyOS concepts, TinyOS implemented
in \nesc)

``whole program'' compilation

1 para introduce basic language concepts:
- components
- interfaces
- based on ANSI C (footnote will evolve to C99)

1 para this not tutorial, see blah for that

\section{Notation}

We use the following notations: the \texttt{typewriter} font is used for
\nesc code and for filenames.

\ldots for elided productions

\section{Concepts and Terminology}

We use the following terminology in the rest of the reference manual:

\begin{itemize}

\item \emph{component}: The basic unit of \nesc programs. Components have a
name and are of two kinds: \emph{modules} and \emph{configurations}. A
component has a \emph{specification} and an implementation. 

\item \emph{specification}: A list of \emph{interface instances},
\emph{commands} and \emph{events} that are \emph{provided} or \emph{used}.

\item \emph{specification element}: An \emph{interface instance},
\emph{command} and \emph{event} in a specification.

\item \emph{module}: A component whose implementation is specified by C code. 

\item \emph{configuration}: A component whose implementation is specified
by \emph{wiring} other components.

\item \emph{interface type}: An \emph{interface type} has a name and
specifies the interaction between two components, \emph{the provider} and
the \emph{user}. This specification takes the form of a set of named
functions called \emph{commands} and \emph{events}.

\item \emph{command}: A function that must be implemented by the provider
of an interface.

\item \emph{event}: A function that must be implemented by the user of
an interface.

%\item \emph{interface function}: A command or event. When the context is
%unambiguous, we will just say function.

\item \emph{interface instance}: An instance of a particular interface type
in the specification of a component. An interface instance has a name, a
\emph{role} (provider or user), an interface type and, optionally,
\emph{interface parameters}. An interface instance without parameters is
a \emph{simple interface instance}, with parameters it is a
\emph{parameterised interface instance}.

\item \emph{interface parameter}: An interface parameter must be of
integral type. There is (conceptually) a separate simple interface instance
for each distinct tuple of parameter values of a parameterised interface
instance.

\item \emph{interface}: When the context is unambiguous, we will say
interface to refer to either an interface type or an interface instance.

\item \emph{task}: A TinyOS task.

\item \emph{scopes}: \nesc has the standard C global, per-block and
per-function scopes. Additionally there is are per-component-specification,
 per-component-implementation and per-interface-type scopes.

\item \emph{extents}: \nesc has the standard C extents: indefinite,
per-function, and per-block.

\item \emph{compile-time error}: An error that the \nesc compiler must
report at compile-time.

\end{itemize}

\section{Interfaces}
\label{sec:interface}

Interfaces in \nesc are bidirectional: they specify the interaction of two
components. An interface has two ``sides'': the provider and the user. The
interface specifies a set of functions, called commands, to be implemented
by the interface's provider and a set of functions, called events, to be
implemented by the interface's user. This section explains how interfaces
are specified, Section~\ref{sec:component} explains how components
specify the interfaces they provide and use, Section~\ref{sec:module}
explains how commands and events are called from C code and
Section~\ref{sec:configuration} explains how components are linked together
via their interfaces.

Interfaces are specified by interface types, as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	\ldots\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
This declares interface type \emph{identifier}. The \emph{declaration-list}
must consist of function declarations with the \kw{command} or \kw{event}
storage class (if not, a compile-time error occurs). An interface can
optionally include C files via the \emph{includes-list} (see
Section~\ref{sec:c}).

A simple interface is:
\begin{verbatim}
interface SendMsg { 
  command result_t send(uint16_t address, uint8_t length, TOS_MsgPtr msg);
  event result_t sendDone(TOS_MsgPtr msg, result_t success);
}
\end{verbatim}

Provides of the \code{SendMsg} interface type must implement \code{send},
while users must implement \code{sendDone}.

\section{Component Specification}
\label{sec:component}

A \nesc component is either a module or a configuration:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\>	\ldots\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\end{tabbing}}
Component's names are specified by the \emph{identifier}. A component can
optionally include C files via the \emph{includes-list} (see
Section~\ref{sec:c}).

The \emph{specification} lists the specification elements (interface
instances, commands or events) used or provided by this component. Each
specification element has a name, a compile-time error occurs if two
specification elements have the same name: \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\end{tabbing}}
There can be multiple \kw{uses} and \kw{provides} directives. Multiple used
or provided specification elements can be grouped in a single directive by
surrounding them with \{ and \}. For instance, the following two
specifications are identical:

\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses interface X;
  uses interface Y;
} ...
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses {
    interface X;
    interface Y;
  }
} ...
\end{verbatim}
\end{minipage}

An interface instance is specified as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\>	\ldots\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

The complete syntax for interface instance declaration is \code{interface X
as Y}, explicitly specifying \code{Y} as the instance's name. The
\code{interface X} syntax is a shorthand for \code{interface X as X}.

If the \emph{parameters} are omitted, then \code{interface X as Y} declares
a single interface to this component. If the \emph{parameters} are present
(e.g., \code{interface SendMsg[uint8\_t id]}) then this interface instance
declares multiple interfaces to this component, one for each distinct tuple
of parameter values (so there are 256 \code{SendMsg} interfaces in the
previous example). The types of the \emph{parameters} must be integral
types (\kw{enum}s are not allowed).
% why no enums?

It is also possible to provide commands and events directly, rather than
via interfaces (but this facility should only be used occasionally as
interfaces provide specification reuse). A command or event is specified,
as in interface types, as a standard C function declaration with
\kw{command} or \kw{event} as its storage class specifier.
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	declaration\\
\>	\ldots\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
It is a compile-time error if the \emph{declaration} is not a function
declaration with the \kw{command} or \kw{event} storage class. 

As with interface instances, commands and events can have integral
parameters. These are specified before the function's argument list, e.g.,
\code{command void send[uint8\_t id](int x)}:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
direct-declarator: \emph{also}\\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
Note that parameters are only allowed inside component specifications, not
inside interface types.

Here is a full specification example:
\begin{verbatim}
configuration GenericComm {
  provides {
    interface StdControl as Control;
    interface SendVarLenPacket as UARTSendRawBytes;
    
    // The interface are parameterised by the active message id
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
  }
  uses {
    // signaled after every send completion for components which wish to
    // retry failed sends
    event result_t sendDone();
  }
} ...
\end{verbatim}
In this example, \code{GenericComm}:
\begin{itemize}
\item Provides simple interface instance \code{Control} of type
\code{StdControl}.
\item Provides simple interface instance \code{UARTSendRawBytes} of type
\code{SendVarLenPacket}.
\item Provides parameterised instances of interface type \code{SendMsg} and
\code{ReceiveMsg}; the parameterised instances are named \code{SendMsg} and
\code{ReceiveMsg} respectively.
\item Uses event \code{sendDone}.
\end{itemize}

\section{Modules}
\label{sec:module}

Modules implement a component specification with C code:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\end{tabbing}}

The name space inside a module has the following hierarchical structure:
\begin{itemize}
\item The outermost scope (the C global scope) contains the C declarations
(see Section~\ref{sec:c}).
\item The next scope (a per-component-specification scope) contains the
specification element names from the module's specification.
\item The next scope (a per-component-implementation scope) contains the
top level declarations of the module's \emph{translation-unit}. These
declarations have indefinite extent and can be: any standard C declaration
or definition, a TinyOS task declaration or definition, a commands or an
event implementation.


\item The remaining scopes are the usual C per-function and per-block scopes.
\end{itemize}

A command or event $F$ of an interface instance $X$ is named $X.F$ inside a
module. It is a compile-time error if command or event $F$ does not 
exist in $X$.

\subsection{Implementing the Module's Specification}

The \emph{translation-unit} must implement the commands and events
required by the module's specification:
\begin{itemize}
\item If a module provides an interface instance $X$ of type $Y$, and
interface type $Y$ has a command $C$, then the module's implementation
must specify a C implementation of a command called $X.C$. 

\item If a module uses an interface instance $X$ of type $Y$, and interface
type $Y$ has an event $E$, then the module's implementation must specify a
C implementation of an event called $X.E$.

\item If a module provides a command (or event) $F$, then the
module's implementation must specify a C implementation for a command (or
event) called $F$.
\end{itemize}

Note that a module that provides or uses an interface can call any of the
interface's commands and signal any of the interface's events.

These command and event declarations are made with the following C
syntax extensions:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
The declaration of command or event $X.F$ of simple interface instance $X$
has the syntax of a C function declaration of $X.F$ with storage class
\kw{command} or \kw{event}. For example, in a module that provides interface
\code{Send} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send(uint16_t address, uint8_t length, TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

The declaration of command or event $X.F$ of parameterised interface
instance $X$, with parameters $P$ has the syntax of a C function
declaration of $X.F$ with storage class \kw{command} or \kw{event} where
the function's arguments are prefixed with the parameters $P$. For example,
in a module that provides interface \code{Send[uint8\_t id]} of type
\kw{SendMsg}:
\begin{verbatim}
command result_t Send.send[uint8_t id](uint16_t address, uint8_t length, 
                                       TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

Compile-time errors are reported when:
\begin{itemize}
\item Any commands or events that must be implemented are missing.
\item The type signature (and optional parameters) of a command or
event does not match that given in the module's specification.
\end{itemize}

\subsection{Calling Commands and Signaling Events}

The following extensions to C syntax are used to call events and signal
commands:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
postfix-expression:\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	\ldots
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}

A command $C$ with no parameters is called with \code{call $C$(...)}, an
event $E$ is signaled with \code{signal $E$(...)}. For instance, in a
module that uses interface \code{Send} of type \kw{SendMsg}:
\code{call Send.send(1, sizeof(Message), &msg1)}.

A command $C$ with parameters $P$ is called with \code{call $C$[$P$](...)}, an
event $E$ is signaled with \code{signal $E$[$P$](...)}. For instance, in a
module that uses interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:
\code{call Send.send[12](1, sizeof(Message), &msg1)}.

Execution of commands and events is immediate, i.e., \kw{call} and 
\kw{signal} behave similarly to function calls. Section~\ref{sec:wiring}
explains what function(s) are actually executed and what result gets
returned.

A module can specify a default implementation for a command that it uses
or an event that it provides [note: need to define this terminology].
These default implementations are called when the command or event is
not connected by any configuration component. Section~\ref{sec:wiring}
explains when default implementations are called. A default command or
event is defined by prefixing a command or event definition with the
\kw{default} keyword:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\end{tabbing}}
For instance, in a in a module that uses interface \code{Send} of type
\kw{SendMsg}:
\begin{verbatim}
default command result_t Send.send(uint16_t address, uint8_t length, 
                                   TOS_MsgPtr msg) {
  return SUCCESS;
}
/* call is allowed even if interface Send is not connected */
... call Send.send(1, sizeof(Message), &msg1) ...
\end{verbatim}

\subsection{Tasks}

A TinyOS task is defined as a function of storage clas \kw{task} returning
\kw{void} and with no arguments: \code{task void myTask() \{ ... \}}.\footnote{\nesc functions with no arguments are declared with
\code{()}, not \code{(void)}. See Section~\ref{sec:c}.} Tasks
are posted by prefixing a call to the task with \kw{post}, e.g., \code{post
myTask()}. A task can also have a forward declaration, e.g., \code{task
void myTask();}.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{task}\\
\\
call-kind: \emph{also one of}\\
\>	\kw{post}
\end{tabbing}}

\section{Configurations}
\label{sec:configuration}

discussion below talks about interface instances only for clarity, but
rules for a provided or used interface instance X are the same as for
provided or used command or event Y.

name space
C
configuration specification
components list

two parts: list of components and wiring.

\subsection{Included components}
list of components: optional renaming for convenience and easier component
subsitution (no need to change wiring); these components are called the
``internal components'' in the rest of this section.

compile-time error if use the same name for two internal components (e.g.,
components foo, bar as foo)

Components are not multiply instantiated: if the same component is used
in two different configurations you still get only one instance of that
component (``foo as bar'' does not change this).

\subsection{Wiring}

- connect an interface instance of this configuration with an interface
instance of an internal component (``equate'')
- connect a provided interface instance of this configuration to a used
interface instance of this configuration (``pass through'')
- connect a used interface instance or an internal componment to a provided
interface instance of an internal component (``link'')

It is legal to wire the same interface multiple times. See the discussion
of wiring semantics below for more details.

All provided and used interfaces of this configuration must be wired in the
wiring section (or compile-time error). However, all interfaces of the
internal components need not be wired (note: they may be wired in another
configuration, or they may be left unwired if the modules have the
appropriate default event or command handlers).

interface instance specification: `interface instance'  optional-parameter-values

interface instance:
- <name> for interface instances of this configuration
- <component name>.<interface instance> (component name is the
optionally renamed name from the list of components): name a particular
instance of a configuration
- <component name> only: see implicit connections discussion below (note:
this form cannot be used when parameter values are specified)
- compile-time error if none of the above

optional-parameter-values: '[' val1, ..., valn ']'. interface instance name
must specify parameterised interface with n parameters, val1 through valn
must be compile-time integer constants (note: see the discussion of
compile-time-constant-functions below). parameter value n must be in the
range of the corresponding parameter type. compile-time error for all
these failures.

an intf instance spec is parameterised if the interface instance name
named a parmaterised interface instance and no parameter values were
specified.

syntax:
equate: intf-spec1 `=' intf-spec2. compile-time error if not both 
provided or both used. exactly one of the two intfs must belong
to this configuration, compile-time error otherwise. 

pass through, link: intf-spec1 `->' intf-spec2 (or, equivalently
intf-spec2 `<-' intf-spec1). intf-spec1 must be used, intf-spec2
must be provided, compile-time error otherwise. Note: somewhat
counter-intuitive for pass through.

In both cases, intf-spec1 and intf-spec2 must be:
- instances of the same interface type
- either: neither is parameterised, or both are and the specified interface
instances have identical parameter types

\subsection{Implicit Connections}

It is possible to write `component1 <-/=/-> component2.interfaceinstance2',
or `component1.interfaceinstance1 <-/=/-> component2'. This syntax iterates
through the interface instances of component1 (resp. component2) to find
all interfaceinstance1s (resp. interfaceinstance2s) which would form a
valid connection. A compile-time error is reported if no such
interfaceinstance1 (resp. interfaceinstance2) can be found, or if more
than one such match can be found.

give examples

\subsection{Wiring Semantics}
\label{sec:wiring}

explain the directed-graph based semantics

per-configuration graph

whole-program graph

meaning of command, event call (graph exploration). two possible
compile-time errors: 
- no reachable command or event defn and no default handler at callee.
- cycle in whole-program graph

multiple reachable commands/events: arbitrary sequential call order,
arbitrary result (of one of the calls) 
% should I specify the result is at least the result of the last call?

parameterised calls:
- from non-parameterised to parameterised: parameter values collected
from configuration
- from parameterised to non-parameterised: conditional call based on
values specified at call site and in configuration (must be =)
- from parameterised to parameterised: values passed through

parameterised calls meet multiple connections:
- parameterised to multiple non-parameterised: ``dispatch table''. must
provide default handler.
- parameterised to multiple non-parameterised and at least one
parameterised: ``dispatch table'' for non-parameterised. as above
for parameterised. default handler not required.

\section{C}
\label{sec:c}

C namespace is populated by:
- loading tos.h 
- loading .h files specified by includes directives at start of
interfaces, modules and configurations

All declarations and macros in these .h files are placed in the C name
space and are therefore known to all subsequently loaded components,
interfaces and C files.

Once foo.h has been loaded by `includes foo', subsequent `includes foo'
directives are ignored.

Example of use: includes fooTypes at start of interface foo will load
fooTypes.h. All components that use or provide foo will then automatically
see the types defined in fooTypes.h.

\subsection{Functions with no arguments, old-style C declarations}

\nesc functions with no arguments are declared with \code{()}, not
\code{(void)}. The latter syntax reports a compile-time error.

Old-style C declarations (with \code{()}) and function definitions 
(parameters specified after the argument list) are not allowed in
interfaces or components (and cause compile-time errors).

Note that neither of these changes apply to C files (so that existing
\file{.h} files can be used unchanged).

\subsection{\nesc and the C preprocessor}

\nesC supports the C preprocessor in all files (interfaces, components and
C files). As an extension, C++-style // comments are also allowed.

- \#define's in a module have per-module scope

- \#include in a module does pure textual inclusion (as it should), so for
instance \#include <math.h> will declare, e.g., sin() as a function declared
in this module. Use the includes directive instead (see Section foo).

\section{Miscellaneous}
\label{sec:misc}

\subsection{Component and Interface Type Name Space}

Components and interface types share a name space; this name space is 
global and distinct from the C global name space. Compile-time error
if expected interface foo and found component foo.

\subsection{Attributes}

explain basic syntax (ref gcc)

\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\end{tabbing}}

C

spontaneous

\subsection{Compile-time Constant Functions}

extension to C (to easily add new kinds of constant expressions in a familiar
syntax).

unique(``string'')

am\_type()

\subsection{Files}

components or interface foo is found in foo.nc

C file foo is found in foo.h

implementation of \nesc uses search path for these files, see man page for
details

\subsection{Compilation Model}

compilation of component loads and checks all code specified directly
and indirectly by a single component, then outputs a single C file
containing all that code. May freely assume that only functions marked
spontaneous are entry points to this code (typical use: main and 
interrupt handlers are marked spontaneous).

\section{Concurrency}
\label{sec:concurrency}

\section{Grammar}
\label{sec:grammar}

The grammar for \nesc is presented as an extension to the ANSI C grammar
from Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr}. Words in \emph{italics} are non-terminals (except
\emph{identifier} which is a terminal), \kw{typewriter} words and symbols
are literal terminals. The subscript \emph{opt} indicates optional
terminals or non-terminals.

The following keywords are new for \nesc: \kw{as}, \kw{call}, \kw{command},
\kw{components}, \kw{configuration}, \kw{event}, \kw{implementation},
\kw{interface}, \kw{module}, \kw{post}, \kw{provides}, \kw{signal},
\kw{task}, \kw{uses}, \kw{includes}. These \nesc keywords are not reserved
in C files. The corresponding C symbols are accessible in \nesc files by
prefixing them with \kw{\_\_nesc\_}\emph{keyword} (e.g.,
\kw{\_\_nesc\_keyword\_as}).

\nesc reserves all identifiers starting with \kw{\_\_nesc} for internal
use. TinyOS reserves all identifiers starting with \kw{TOS\_} and
\kw{TOSH\_}.

\nesc files follow the \emph{nesC-file} production; \file{.h} files included
via the \kw{includes} directive follow the \emph{translation-unit}
directive from K\&R. 

New rules:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\\
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\\
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	parameterised-identifier\\
\>	endpoint \kw{.} parameterised-identifier\\
\\
parameterised-identifier:\\
\>	identifier\\
\>	identifier \kw{[} argument-expression-list \kw{]}\\
\\
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\\
specification-element:\\
\>	declaration\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

Changed rules: \emph{also} indicates additional productions for existing
non-terminals, \emph{replaced by} indicates replacement of an existing
non-terminal:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{task}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\\
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\\
postfix-expression: \emph{replaced by}\\
\>	primary-expression\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	postfix-expression \kw{.} identifier\\
\>	postfix-expression \kw{->} identifier\\
\>	postfix-expression \kw{++}\\
\>	postfix-expression \kw{--}\\
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}


\end{document}
