% ponder: should I define a minimum reachable fn defn ?
% (this def affects what ``missing connection'' errors you get)

% talk more about load order (affects behaviour because of includes)

\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{xspace}

\newcommand{\kw}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\nesc}{nesC\xspace}
\newcommand{\opt}{$_\mbox{opt}$\xspace}

\parskip 0.15cm
\parindent 0cm

\begin{document}

\section{Introduction}

1 para goal (execution model embodies TinyOS concepts, TinyOS implemented
in \nesc)

``whole program'' compilation

1 para introduce basic language concepts:
- components
- interfaces
- based on ANSI C (footnote will evolve to C99)

1 para this not tutorial, see blah for that

\section{Notation}

We use the following notations: the \texttt{typewriter} font is used for
\nesc code and for filenames.

\ldots for elided productions

\section{Concepts and Terminology}

We use the following terminology in the rest of the reference manual:

\begin{itemize}

\item \emph{component}: The basic unit of \nesc programs. Components have a
name and are of two kinds: \emph{modules} and \emph{configurations}. A
component has a \emph{specification} and an implementation. 

\item \emph{specification}: A list of \emph{interface instances},
\emph{commands} and \emph{events} that are \emph{provided} or \emph{used}.

\item \emph{specification element}: An \emph{interface instance},
\emph{command} and \emph{event} in a specification.

\item \emph{module}: A component whose implementation is specified by C code. 

\item \emph{configuration}: A component whose implementation is specified
by \emph{wiring} other components.

\item \emph{interface type}: An \emph{interface type} has a name and
specifies the interaction between two components, \emph{the provider} and
the \emph{user}. This specification takes the form of a set of named
functions called \emph{commands} and \emph{events}.

\item \emph{command}: A function that must be implemented by the provider
of an interface.

\item \emph{event}: A function that must be implemented by the user of
an interface.

%\item \emph{interface function}: A command or event. When the context is
%unambiguous, we will just say function.

\item \emph{interface instance}: An instance of a particular interface type
in the specification of a component. An interface instance has a name, a
\emph{role} (provider or user), an interface type and, optionally,
\emph{interface parameters}. An interface instance without parameters is
a \emph{simple interface instance}, with parameters it is a
\emph{parameterised interface instance}.

\item \emph{interface parameter}: An interface parameter must be of
integral type. There is (conceptually) a separate simple interface instance
for each distinct tuple of parameter values of a parameterised interface
instance.

\item \emph{interface}: When the context is unambiguous, we will say
interface to refer to either an interface type or an interface instance.

\item \emph{task}: A TinyOS task.

\item \emph{scopes}: \nesc has the standard C global, per-block and
per-function scopes. Additionally there is are per-component-specification,
 per-component-implementation and per-interface-type scopes.

\item \emph{extents}: \nesc has the standard C extents: indefinite,
per-function, and per-block.

\item \emph{compile-time error}: An error that the \nesc compiler must
report at compile-time.

\end{itemize}

\section{Interfaces}
\label{sec:interface}

Interfaces in \nesc are bidirectional: they specify the interaction of two
components. An interface has two ``sides'': the provider and the user. The
interface specifies a set of functions, called commands, to be implemented
by the interface's provider and a set of functions, called events, to be
implemented by the interface's user. This section explains how interfaces
are specified, Section~\ref{sec:component} explains how components
specify the interfaces they provide and use, Section~\ref{sec:module}
explains how commands and events are called from C code and
Section~\ref{sec:configuration} explains how components are linked together
via their interfaces.

Interfaces are specified by interface types, as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	\ldots\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
This declares interface type \emph{identifier}. The \emph{declaration-list}
must consist of function declarations with the \kw{command} or \kw{event}
storage class (if not, a compile-time error occurs). An interface can
optionally include C files via the \emph{includes-list} (see
Section~\ref{sec:c}).

A simple interface is:
\begin{verbatim}
interface SendMsg { 
  command result_t send(uint16_t address, uint8_t length, TOS_MsgPtr msg);
  event result_t sendDone(TOS_MsgPtr msg, result_t success);
}
\end{verbatim}

Provides of the \code{SendMsg} interface type must implement \code{send},
while users must implement \code{sendDone}.

\section{Component Specification}
\label{sec:component}

A \nesc component is either a module or a configuration:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\>	\ldots\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\end{tabbing}}
Component's names are specified by the \emph{identifier}. A component can
optionally include C files via the \emph{includes-list} (see
Section~\ref{sec:c}).

The \emph{specification} lists the specification elements (interface
instances, commands or events) used or provided by this component. Each
specification element has a name, a compile-time error occurs if two
specification elements have the same name: \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\end{tabbing}}
There can be multiple \kw{uses} and \kw{provides} directives. Multiple used
or provided specification elements can be grouped in a single directive by
surrounding them with \{ and \}. For instance, the following two
specifications are identical:

\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses interface X;
  uses interface Y;
} ...
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
module A1 {
  uses {
    interface X;
    interface Y;
  }
} ...
\end{verbatim}
\end{minipage}

An interface instance is specified as follows:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\>	\ldots\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

The complete syntax for interface instance declaration is \code{interface X
as Y}, explicitly specifying \code{Y} as the instance's name. The
\code{interface X} syntax is a shorthand for \code{interface X as X}.

If the \emph{parameters} are omitted, then \code{interface X as Y} declares
a single interface to this component. If the \emph{parameters} are present
(e.g., \code{interface SendMsg[uint8\_t id]}) then this interface instance
declares multiple interfaces to this component, one for each distinct tuple
of parameter values (so there are 256 \code{SendMsg} interfaces in the
previous example). The types of the \emph{parameters} must be integral
types (\kw{enum}s are not allowed).
% why no enums?

It is also possible to provide commands and events directly, rather than
via interfaces (but this facility should only be used occasionally as
interfaces provide specification reuse). A command or event is specified,
as in interface types, as a standard C function declaration with
\kw{command} or \kw{event} as its storage class specifier.
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
specification-element:\\
\>	declaration\\
\>	\ldots\\
\\
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\end{tabbing}}
It is a compile-time error if the \emph{declaration} is not a function
declaration with the \kw{command} or \kw{event} storage class. 

As with interface instances, commands and events can have integral
parameters. These are specified before the function's argument list, e.g.,
\code{command void send[uint8\_t id](int x)}:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
direct-declarator: \emph{also}\\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
Note that parameters are only allowed inside component specifications, not
inside interface types.

Here is a full specification example:
\begin{verbatim}
configuration GenericComm {
  provides {
    interface StdControl as Control;
    interface SendVarLenPacket as UARTSendRawBytes;
    
    // The interface are parameterised by the active message id
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
  }
  uses {
    // signaled after every send completion for components which wish to
    // retry failed sends
    event result_t sendDone();
  }
} ...
\end{verbatim}
In this example, \code{GenericComm}:
\begin{itemize}
\item Provides simple interface instance \code{Control} of type
\code{StdControl}.
\item Provides simple interface instance \code{UARTSendRawBytes} of type
\code{SendVarLenPacket}.
\item Provides parameterised instances of interface type \code{SendMsg} and
\code{ReceiveMsg}; the parameterised instances are named \code{SendMsg} and
\code{ReceiveMsg} respectively.
\item Uses event \code{sendDone}.
\end{itemize}

\section{Modules}
\label{sec:module}

Modules implement a component specification with C code:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\end{tabbing}}

The name space inside a module has the following hierarchical structure:
\begin{itemize}
\item The outermost scope (the C global scope) contains the C declarations
(see Section~\ref{sec:c}).
\item The next scope (a per-component-specification scope) contains the
specification element names from the module's specification.
\item The next scope (a per-component-implementation scope) contains the
top level declarations of the module's \emph{translation-unit}. These
declarations have indefinite extent and can be: any standard C declaration
or definition, a TinyOS task declaration or definition, a commands or an
event implementation.


\item The remaining scopes are the usual C per-function and per-block scopes.
\end{itemize}

A command or event $F$ of an interface instance $X$ is named $X.F$ inside a
module. It is a compile-time error if command or event $F$ does not 
exist in $X$.

\subsection{Implementing the Module's Specification}

The \emph{translation-unit} must implement the commands and events
required by the module's specification:
\begin{itemize}
\item If a module provides an interface instance $X$ of type $Y$, and
interface type $Y$ has a command $C$, then the module's implementation
must specify a C implementation of a command called $X.C$. 

\item If a module uses an interface instance $X$ of type $Y$, and interface
type $Y$ has an event $E$, then the module's implementation must specify a
C implementation of an event called $X.E$.

\item If a module provides a command (or event) $F$, then the
module's implementation must specify a C implementation for a command (or
event) called $F$.
\end{itemize}

Note that a module that provides or uses an interface can call any of the
interface's commands and signal any of the interface's events.

These command and event declarations are made with the following C
syntax extensions:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\end{tabbing}}
The declaration of command or event $X.F$ of simple interface instance $X$
has the syntax of a C function declaration of $X.F$ with storage class
\kw{command} or \kw{event}. For example, in a module that provides interface
\code{Send} of type \kw{SendMsg}:
\begin{verbatim}
command result_t Send.send(uint16_t address, uint8_t length, TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

The declaration of command or event $X.F$ of parameterised interface
instance $X$, with parameters $P$ has the syntax of a C function
declaration of $X.F$ with storage class \kw{command} or \kw{event} where
the function's arguments are prefixed with the parameters $P$. For example,
in a module that provides interface \code{Send[uint8\_t id]} of type
\kw{SendMsg}:
\begin{verbatim}
command result_t Send.send[uint8_t id](uint16_t address, uint8_t length, 
                                       TOS_MsgPtr msg) {
  ...
  return SUCCESS;
}
\end{verbatim}

Compile-time errors are reported when:
\begin{itemize}
\item Any commands or events that must be implemented are missing.
\item The type signature (and optional parameters) of a command or
event does not match that given in the module's specification.
\end{itemize}

\subsection{Calling Commands and Signaling Events}

The following extensions to C syntax are used to call events and signal
commands:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
postfix-expression:\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	\ldots
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}

A command $C$ with no parameters is called with \code{call $C$(...)}, an
event $E$ is signaled with \code{signal $E$(...)}. For instance, in a
module that uses interface \code{Send} of type \kw{SendMsg}:
\code{call Send.send(1, sizeof(Message), &msg1)}.

A command $C$ with parameters $P$ is called with \code{call $C$[$P$](...)}, an
event $E$ is signaled with \code{signal $E$[$P$](...)}. For instance, in a
module that uses interface \code{Send[uint8\_t id]} of type \kw{SendMsg}:
\code{call Send.send[12](1, sizeof(Message), &msg1)}.

Execution of commands and events is immediate, i.e., \kw{call} and 
\kw{signal} behave similarly to function calls. Section~\ref{sec:wiring}
explains what function(s) are actually executed and what result gets
returned.

A module can specify a default implementation for a command that it uses
or an event that it provides [note: need to define this terminology].
These default implementations are called when the command or event is
not connected by any configuration component. Section~\ref{sec:wiring}
explains when default implementations are called. A default command or
event is defined by prefixing a command or event definition with the
\kw{default} keyword:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\end{tabbing}}
For instance, in a in a module that uses interface \code{Send} of type
\kw{SendMsg}:
\begin{verbatim}
default command result_t Send.send(uint16_t address, uint8_t length, 
                                   TOS_MsgPtr msg) {
  return SUCCESS;
}
/* call is allowed even if interface Send is not connected */
... call Send.send(1, sizeof(Message), &msg1) ...
\end{verbatim}

\subsection{Tasks}

A TinyOS task is defined as a function of storage clas \kw{task} returning
\kw{void} and with no arguments: \code{task void myTask() \{ ... \}}.\footnote{\nesc functions with no arguments are declared with
\code{()}, not \code{(void)}. See Section~\ref{sec:c}.} Tasks
are posted by prefixing a call to the task with \kw{post}, e.g., \code{post
myTask()}. A task can also have a forward declaration, e.g., \code{task
void myTask();}.  \emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{task}\\
\\
call-kind: \emph{also one of}\\
\>	\kw{post}
\end{tabbing}}

\section{Configurations}
\label{sec:configuration}

Configurations implement a component specification by connecting, or wiring,
other components:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\end{tabbing}}

The \emph{component-list} lists the components that are used to build this
configuration, the \emph{connection-list} specifies how these components
are wired together and to the configuration's specification.

The name space inside a module has the following hierarchical structure:
\begin{itemize}
\item The outermost scope (the C global scope) contains the C declarations
(see Section~\ref{sec:c}).
\item The next scope (a per-component-specification scope) contains the
specification element names from the configuration's specification.
\item The next scope (a per-component-implementation scope) contains the
names of the components used in this configuration.
\end{itemize}

In the rest of this section, we call specification elements from the
configuration's specification \emph{external},
and specification elements from one of the configuration's components
\emph{internal}.

\subsection{Included components}

The \emph{component-list} specifies the components used to build this
configuration. These components can be optionally renamed within the
configuration, either to avoid name conflicts with the configuration's
specification elements, or to simplify changing the components a
configuration uses (to avoid having to change the wiring):
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\end{tabbing}}

A compile-time error occurs if two components are given the same name using \kw{as} (e.g., \code{components X, Y as X}).

There is only ever a single instance of a component: if a component $X$
is used in two different configurations (or even twice within the same
configuration) there is still only instance of $X$ (and its variables)
in the program.

\subsection{Wiring}

Wiring is used to connect specification elements (interfaces, commands,
events) together. Taken together, all the wiring statements of a particular
program determine which functions get called at each \kw{call} and
\kw{signal} statement:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\end{tabbing}}

Wiring statements connect two \emph{endpoints}. The \emph{identifier-path}
of an \emph{endpoint} specifies a specification element. The
\emph{argument-expression-list} optionally specifies some parameter
values. We say that an endpoint is parameterised if its specification
element is parameterised and the endpoint has no parameter values. A
compile-time error occurs if an endpoint has parameter values and any of
the following is true:
\begin{itemize}
\item The parameter values are not all constant expressions.
\item The endpoint's specification element is not parameterised.
\item The parameter values are not in range for the specification element's
parameter types.
\end{itemize}

A compile-time error occurs if the \emph{identifier-path} of an \emph{endpoint} is not of the three following forms:
\begin{itemize}
\item $X$, where $X$ names an external specification element.
\item $C.X$ where $C$ is a component from the \emph{component-list} and
$X$ is a specification element of $C$.
\item $C$ where $C$ is a component name from the \emph{component-list}.
This form is used in implicit connections, discussed in
Section~\ref{sec:implicit}. Note that this form cannot be used when
parameter values are specified.
\end{itemize}

There are three wiring statements in \nesc:
\begin{itemize}
\item \emph{endpoint}$_1$ \code{=} \emph{endpoint}$_2$ \ (equate wires):
Any connection involving an external specification element. These
effectively make two specification elements equivalent.

Let $S_1$ be the specification element of \emph{endpoint}$_1$ and $S_2$
that of \emph{endpoint}$_2$. One of the following two conditions must hold
or a compile-time error occurs:
\begin{itemize}
\item $S_1$ is internal, $S_2$ is external (or vice-versa) and $S_1$ and
$S_2$ are both provided or both used,
\item $S_1$ and $S_2$ are both external and one is provided and the other used.
\end{itemize}

\item \emph{endpoint}$_1$ \code{->} \emph{endpoint}$_2$ \ (link wires): A
connection involving two internal specification elements. Link wires always
connect a used specification element specified by \emph{endpoint}$_1$ to a
provided one specified by \emph{endpoint}$_2$ . If these two conditions do
not hold, a compile-time error occurs.

\item \emph{endpoint}$_1$ \code{<-} \emph{endpoint}$_2$ is equivalent to
\emph{endpoint}$_2$ \code{->} \emph{endpoint}$_1$.
\end{itemize}

In all three kinds of wiring, the two specification elements specified must
be compatible, i.e., they must both be commands, or both be events, or both
be interface instances. Also, if they are commands (or events), then they
must both have the same function signature. If they are interface instances
they must be of the same interface type. If these conditions do not hold,
a compile-time error occurs.

If one endpoint is parameterised, the other must be too and must have the
same parameter types; otherwise a compile-time error occurs.

It is legal to wire the same specification element multiple times. The
discussion of wiring semantics in Section~\ref{sec:wiring} explains \nesc's
behaviour in this case.

All external specification elements must be wired or a compile-time error
occurs. However, internal specification elements may be left unconnected
(these may be wired in another configuration, or they may be left unwired
if the modules have the appropriate \kw{default} event or command
functions).

\subsection{Implicit Connections}
\label{sec:implicit}

It is possible to write \code{C1 <- C2.I} or \code{C1.I <- C2} (and the
same with \kw{=}, or \kw{->}). This syntax iterates through the
specification elements of \code{C1} (resp. \code{C2}) to find a
specification element \code{J} such that \code{C1.J <- C2.I}
(resp. \code{C1.I <- C2.J}) forms a valid connection. If exactly one such
\code{J} can be found, then the connection is made, otherwise a
compile-time error occurs.

For instance, with:
\begin{verbatim}
module M1 {                              module M2 {
  provides interface StdControl;           uses interface StdControl as SC;
} ...                                    } ...

              configuration C { }
              implementation {
                components M1, M2;
                M2.SC -> M1;
              }
\end{verbatim}
The \code{M2.SC -> M1} line is equivalent to \code{M2.SC -> M1.StdControl}.

\subsection{Wiring Semantics}
\label{sec:wiring}

The semantics of wiring are defined in terms of the program's wiring graph,
a directed graph which connects nodes representing command or event calls
to nodes representing command or event definitions.

The program's wiring graph is built by assembling the \emph{configuration
graphs} of each configuration (by unioning their node and edge sets).
A \emph{configuration graph} is a directed graph representing the wiring
specified in a single configuration.

We first introduce some notation. Node names are of the form $C.F.P$ for
command or event $F$ in component $C$'s specification with parameter values
$P$, $C.I.F.P$ for command or event $F$ in interface instance $I$ of $C$'s
specification with parameter values $P$. We write the empty tuple as $()$.
All endpoints in the wiring can be viewed as being of the form $D.I.P$ with
$P = ()$ when no parameters are specified and $D = C$ if $I$ is an external
specification element.  All wires can be viewed as being of the form
$C_1.I_1.P_1 \kw{to} C_2.I_2.P_2$ where $I_1$ is used if $C_1 \not= C$ and
provided if $C_1 = C$, and $I_2$ is provided if $C_2 \not= C$ and used if
$C_2 = C$.

The functions of specification element $I$ of component $C$ with parameters
$P$, $\FSE(C, I, P)$, are defined as:
\begin{itemize}
\item $\FSE(C, I, P) = \{ C.I.P \}$ if $I$ is a command or event.
\item $\FSE(C, I, P) = \{ C.I.F.P | F \mbox{is a command or event of} I \}$ if
$I$ is an interface instance.
\end{itemize}

We define a connection function for connecting two endpoints:
$\connect(ep_1, ep_2)$ returns a set of directed edges as follows:
\begin{itemize}
\item $\connect(C_1.I_1.P_1, C_2.I_2.P_2) = \{ (C_1.I_1.P_1, C_2.I_2.P_2)
\}$ if $I_1$ is a command or event.
\item $\connect(C_1.I_1.P_1, C_2.I_2.P_2) = 
\{ C_1.I_1.F.P_1, C_2.I_2.F.P_2) | F \mbox{is a command in} I_1 \} \cup
\{ C_2.I_2.F.P_2, C_1.I_1.F.P_1) | F \mbox{is an event in} I_1 \}$ if $I_1$ is an interface instance.
\end{itemize}

Configuration graph $(V,E)$ for configuration $C$ is the smallest graph
such that:
\begin{itemize}
\item For each wire $C_1.I_1.P_1 \kw{to} C_2.I_2.P_2$:
$\FSE(C_1, I_1, ()) \cup \FSE(C_2, I_2, ()) \cup \FSE(C_1, I_1, P_1) \cup
\FSE(C_2, I_2, P_2) \in V$.

\item For each wire $C_1.I_1.P_1 \kw{to} C_2.I_2.P_2$:
$\connect(C_1.I_1.P_1, C_2.I_2.P_2) \in E$. If $P_1 \not= ()$ then
$\connect(C_1.I_1.(), C_1.I_1.P_1) \in E$. If $P_2 \not= ()$ then
$\connect(C_2.I_2.P_2, C_2.I_2.()) \in E$.
\end{itemize}

The semantics of a call to a command or event $F$ of interface $I$ in
module $M$ are now easily defined, given the whole program graph $G$,

First, if there is a cycle in $G$ starting at $M.I.F.()$ a compile-time
error occurs.

Otherwise, set $S$ is the set of reachable command or event definitions
from $M.I.F.()$. 

% This is still missing parameter value collection

If $F$ is a non-parameterised call, then:
\begin{itemize}
\item If $S$ is empty and $M$ has no default defintion for $I.F$, a
compile-time error occurs.
\item If $S$ is empty and $M$ has a default defintion $F'$ for $I.F$, then
$F'$ is called.
\item If $S$ is non-empty: the elements of $S$ are called in an arbitrary
order.
\end{itemize}

If $F$ is a parameterised call with parameter values $P$ (computed at
runtime in $M$), then $S$ is split into two sets: $S_1$ contains the
parameterised definitions, $S_2$ the non-parameterised ones whose
condition matches $P$.
\begin{itemize}
\item If $S_1$ is empty and there is no default definition for $I.F$, then
a compile-time error occurs.
\item If $S_1 \cup S_2$ is empty and $M$ has a default definition
$F'$ for $I.F$, then $F'$ is called.
\item If $S_1 \cup S_2$ is non-empty: the elements of $S_1 \cup S_2$ are
called in an arbitrary order.
\end{itemize}

The result of $I.F$ is the result of one of the functions called (note that
the rules above guarantee that at least one function will always be called).
% we could change this to ``last function called''

\section{C}
\label{sec:c}

The C global scope is populated by including C \file{.h} files. All
macro and C declarations and definitions in these files are placed in the
global C scope and are available to all subsequently loaded components,
interfaces and C files. Similarly, if a \kw{\#define} macros is undefined,
then it will remain undefined for subsequently loaded files.

A C file called \file{tos.h} is automatically
included before any components. Subsequent C files are loaded according
to the \kw{includes} directives found at the start of component and
interface files:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\end{tabbing}}

An \code{includes X} directive tells \nesc to load C file \file{X.h}. Once
\file{X.h} has been loaded, all subsequent \code{includes X} directives
are ignored.

As an example, interface type \code{Bar} might include C file
\file{BarTypes.h} which defines types used in the interface:

\begin{minipage}[t]{3in}
\begin{verbatim}
Bar.nc:
includes BarTypes;
interface Bar {
  command result_t bar(BarType arg1);
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{3in}
\begin{verbatim}
BarTypes.h:
typedef struct {
  int x;
  double y;
} BarType;
\end{verbatim}
\end{minipage}

\subsection{Functions with no arguments, old-style C declarations}

\nesc functions with no arguments are declared with \code{()}, not
\code{(void)}. The latter syntax reports a compile-time error.

Old-style C declarations (with \code{()}) and function definitions 
(parameters specified after the argument list) are not allowed in
interfaces or components (and cause compile-time errors).

Note that neither of these changes apply to C files (so that existing
\file{.h} files can be used unchanged).

\subsection{\nesc and the C preprocessor}

\nesC supports the C preprocessor in all files (interfaces, components and
C files). As an extension, C++-style // comments are also allowed.

The effect of \kw{\#define} and \kw{\#undef} within components is
limited to the component in which they occur (this is somewhat like
having a per-component scope for preprocessor macros).

While \kw{\#include} directives are allowed in components and interfaces,
they are unlikely to be useful. For instance, a \code{\#include <math.h>}
directive will produce the following effects:
\begin{itemize}
\item In a configuration or interface type file: various compilation errors.
\item In a module: this will declare a number of functions (e.g., \code{sin})
in the module's per-component-implementation scope. This is obviously
not very useful.
\end{itemize}

\section{Miscellaneous}
\label{sec:misc}

\subsection{Component and Interface Type Name Space}

Components and interface types share a name space; this name space is 
global and distinct from the C global name space. Compile-time error
if expected interface foo and found component foo.

\subsection{Attributes}

\nesc uses gcc's~\cite{gcc} \kw{\_\_attribute\_\_} syntax for
declaring some properties of functions. These attributes can be placed
either on function definitions or function declarations (after the
parameter list).\footnote{gcc doesn't allow attributes after the
parameter list in function definitions.} The attributes of a function
$f$ are the union of all attributes on all declarations and
definitions of $f$.

The attribute syntax in \nesc is:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\end{tabbing}}

\nesc supports two attributes:
\begin{itemize}
\item \code{C}: This attribute is used for a function $f$ declared in
modules (it is ignored for all other declarations). It specifies that
$f$'s should appear in the global C scope rather than in the module's
per-component-implementation scope. This allows $f$ to be called from
C code.

\item \code{spontaneous}: This attribute can be used on any function
$f$ (in modules or C code). It indicates that there are calls $f$ that
are not visible in the source code. Typically, functions that are
called spontaneously are interrupt handlers, and the C \code{main}
function. Section~\ref{sec:cmodel} discusses how the \nesc compiler
uses the \code{spontaneous} attribute during compilation.
\end{itemize}

Example of attribute use: in module \file{RealMain.td}:
\begin{verbatim}
module RealMain { ... }
implementation {
  int main(int argc, char **argv) __attribute__((C, spontaneous)) {
    ...
  }
}
\end{verbatim}

This example declares that function \code{main} should actually appear
in the C global scope (\code{C}), so that the linker can find it. It
also declares that \code{main} can be called even though there are no
function calls to \code{main} anywhere in the program
(\code{spontaneous}). 

\subsection{Compile-time Constant Functions}

\nesc has a new kind of constant expression: \emph{constant
functions}. These are functions defined within the language which
evaluate to a constant at compile-time.

\nesc currently has one constant function, \code{unique}. More are planned
for the near future.

\code{unsigned int unique(char *identifier)} \\ Returns: if the program
contains $n$ calls to \code{unique} with the same \code{identifier}
string, each calls returns a different unsigned integer in the range
$0 .. n-1$.

The intended use of \code{unique} is for passing a unique integer
to parameterised interface instances, so that a component providing
a parameterised interface can uniquely identify the various components
connected to that interface.

\subsection{Files and Compilation Model}
\label{sec:cmodel}

The \nesc compiler assumes that a component or interface $x$ is found
in a file called \file{$x$.nc}, and that an included C file $y$ is
found in a file called \file{$y$.h}. The current implementation of
the \nesc uses a search path to locate these files (details can be
found in the \file{ncc} manual).

The \nesc compiler's input is a component $c$ to be compiled. The compiler
locates $c$'s file, loads and compiles this file and the files for all
components, interfaces and C files used (directly or indirectly) by $c$.
The compiler may assume that the only entry points to this component
are the functions marked with the \code{spontaneous} attribute.

\section{Concurrency}
\label{sec:concurrency}

\section{Grammar}
\label{sec:grammar}

The grammar for \nesc is presented as an extension to the ANSI C grammar
from Appendix~A of Kernighan and Ritchie (K\&R)
~\cite[pp234--239]{kandr}. Words in \emph{italics} are non-terminals (except
\emph{identifier} which is a terminal), \kw{typewriter} words and symbols
are literal terminals. The subscript \emph{opt} indicates optional
terminals or non-terminals.

The following keywords are new for \nesc: \kw{as}, \kw{call}, \kw{command},
\kw{components}, \kw{configuration}, \kw{event}, \kw{implementation},
\kw{interface}, \kw{module}, \kw{post}, \kw{provides}, \kw{signal},
\kw{task}, \kw{uses}, \kw{includes}. These \nesc keywords are not reserved
in C files. The corresponding C symbols are accessible in \nesc files by
prefixing them with \kw{\_\_nesc\_}\emph{keyword} (e.g.,
\kw{\_\_nesc\_keyword\_as}).

\nesc reserves all identifiers starting with \kw{\_\_nesc} for internal
use. TinyOS reserves all identifiers starting with \kw{TOS\_} and
\kw{TOSH\_}.

\nesc files follow the \emph{nesC-file} production; \file{.h} files included
via the \kw{includes} directive follow the \emph{translation-unit}
directive from K\&R. 

New rules:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
nesC-file: \\
\>	includes-list\opt interface\\
\>	includes-list\opt module\\
\>	includes-list\opt configuration\\
\\
includes-list:\\
\>	includes\\
\>	includes-list includes\\
\\
includes:\\
\>	\kw{includes} identifier-list \kw{;}\\
\\
interface:\\
\>	\kw{interface} identifier \kw{\{} declaration-list \kw{\}}\\
\\
module:\\
\>	\kw{module} identifier specification module-implementation\\
\\
module-implementation:\\
\>	\kw{implementation} \kw{\{} translation-unit \kw{\}}\\
\\
configuration:\\
\>	\kw{configuration} identifier specification configuration-implementation\\
\\
configuration-implementation:\\
\>	\kw{implementation} \kw{\{} component-list\opt connection-list \kw{\}}\\
\\
component-list:\\
\>	components\\
\>	component-list components\\
\\
components:\\
\>	\kw{components} component-line \kw{;}\\
\\
component-line:\\
\>	renamed-identifier\\
\>	component-line \kw{,} renamed-identifier\\
\\
renamed-identifier:\\
\>	identifier\\
\>	identifier \kw{as} identifier\\
\\
connection-list:\\
\>	connection\\
\>	connection-list connection\\
\\
connection:\\
\>	endpoint \kw{=} endpoint\\
\>	endpoint \kw{->} endpoint\\
\>	endpoint \kw{<-} endpoint\\
\\
endpoint:\\
\>	identifier-path \\
\>	identifier-path \kw{[} argument-expression-list \kw{]}\\
\\
identifier-path:\\
\>	identifier\\
\>	identifier-path \kw{.} identifier\\
\\
specification:\\
\>	\kw{\{} uses-provides-list \kw{\}}\\
\\
uses-provides-list:\\
\>	uses-provides\\
\>	uses-provides-list uses-provides\\
\\
uses-provides:\\
\>	\kw{uses} specification-element-list\\
\>	\kw{provides} specification-element-list\\
\\
specification-element-list:\\
\>	specification-element\\
\>	\kw{\{} specification-elements \kw{\}}\\
\\
specification-elements:\\
\>	specification-element\\
\>	specification-elements specification-element\\
\\
specification-element:\\
\>	declaration\\
\>	\kw{interface} renamed-identifier parameters\opt\\
\\
parameters:\\
\>	\kw{[} parameter-type-list \kw{]}
\end{tabbing}}

Changed rules: \emph{also} indicates additional productions for existing
non-terminals, \emph{replaced by} indicates replacement of an existing
non-terminal:
\emph{\begin{tabbing}
\hspace*{2cm}\= \\ \kill
storage-class-specifier: \emph{also one of}\\
\>	\kw{command} \kw{event} \kw{task}\\
\\
declaration-specifiers: \emph{also}\\
\>	\kw{default} declaration-specifiers\\
\\
direct-declarator: \emph{also}\\
\>	identifier \kw{.} identifier \\
\>	direct-declarator parameters \kw{(} parameter-type-list \kw{)}\\
\\
init-declarator-list: \emph{also}\\
\>	init-declarator attributes\\
\>	init-declarator-list \kw{,} init-declarator attributes\\
\\
function-definition: \emph{also}\\
\>	declaration-specifiers\opt declarator attributes declaration-list\opt compound-statement\\
\\
attributes:\\
\>	attribute\\
\>	attributes attribute\\
\\
attribute:\\
\>	\kw{\_\_attribute\_\_} \kw{(} \kw{(} attribute-list \kw{)} \kw{)}\\
\\
attribute-list:\\
\>	single-attribute\\
\>	attribute-list \kw{,} single-attribute\\
\\
single-attribute:\\
\>	identifier\\
\>	identifier \kw{(} argument-expression-list \kw{)}\\
\\
postfix-expression: \emph{replaced by}\\
\>	primary-expression\\
\>	postfix-expression \kw{[} argument-expression-list \kw{]}\\
\>	call-kind\opt primary \kw{(} argument-expression-list\opt \kw{)}\\
\>	postfix-expression \kw{.} identifier\\
\>	postfix-expression \kw{->} identifier\\
\>	postfix-expression \kw{++}\\
\>	postfix-expression \kw{--}\\
\\\\
call-kind: \emph{one of}\\
\>	\kw{call} \kw{signal} \kw{post}
\end{tabbing}}


\end{document}
